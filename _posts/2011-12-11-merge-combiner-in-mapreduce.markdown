--- 
title: Merge/Combiner in MapReduce
type: post
layout: post
tags: 
- MapReduce
---
  Map的输出需要经过merge（可能还有combiner）后，才会作为Ｒeduce的输入。<br />  在ＭapＲeduce中，merge作为reduce task的一部分，有三种Ｍerge方式：<br /><ol><li>in memory merge (在内容中进行merge)</li><li>intermediated memory to memory　（"内存到内存"的merge）</li><li>in disk　（硬盘中进行merge）</li></ol>  关于merge的输入和返回：<br /><ol><li>merge的输入是ＭapOutput<K,V>类型，具体的输入内容根据merge的方式而定，当进行in-memory或intermediated m2m的merge时，从内存中读取输入，当进行in disk merge时，输入是path组成的list，从disk上的临时文件中读取输入;</li><li>merge的返回的是RawKeyValueIterator类型，写入文件;</li></ol>  关于combiner：<br /><ol><li>若没有配置combiner class，执行完merge后会直接调用writeFile;</li><li>当设置了combiner class时，merge的输出将作为combiner的输入；执行完merge操作后，调用 combineAndSpill(rIter, reduceCombineInputCounter)进行combine操作，buff中的数据达到一定阈值时，spill到disk.</li><li>combiner也是Reducer类型，在Ｍap输出后做combiner，本质上是调用了combiner的reduce()方法，提前进行了reduce操作.</li></ol><br />－－－以下内容转自tbdata.org评论－－－<br /><div style="background-color: #cccccc;"><cite>Denny Ye</cite> <span>说道：</span>      </div><div style="background-color: #cccccc;"><a href="http://www.tbdata.org/archives/1470/comment-page-1#comment-5101">    四月 1, 2011 11:29 上午</a>  </div><span style="background-color: #cccccc;">    </span><div style="background-color: #cccccc;">Shuffle过程中, Reduce端需要不断地对从map端拉过来的数据做merge。最好的情况是就在内存中做merge，完了后直接作为reduce的输入数据。</div><span style="background-color: #cccccc;"> </span><div style="background-color: #cccccc;">开启这种MemToMem merge模式是将mapreduce.reduce.merge.memtomem.enabled设置为true。   当copy过来的数据太多时，超过一个内存限制，就会往磁盘做merge，我们应该最大限度地减少往磁盘merge，在这里设置 mapreduce.reduce.shuffle.merge.percent，这个一个利用memoryLimit的比例，我给它设置为0.99,最 大化地利用reduce端的内存来做merge。最后在做过一些内存间的merge后，你希望有多少内存来存储reduce的输入数 据？mapreduce.reduce.input.buffer.percent，这个比例设置高些，这个数据设置的越大，在merge后期往磁盘 merge数据就越少。我测试时设置是0.9。</div><span style="background-color: #cccccc;"> </span><div style="background-color: #cccccc;">在我的测试例子中，reduce端的所有merge处理都是在内存中发生，没有往磁盘写一点数据。merge流程从最初的接近8分钟减少到2分钟，这2分钟基本就是在拉取数据，内存中merge是很快的。</div><span style="background-color: #cccccc;"> </span><div style="background-color: #cccccc;">当然基于测试的数据是很理想化的，但上述的设置还是能最大化地减少reduce端对磁盘IO的操作。<br />因为我测试的初衷是尽量让磁盘读写不要成为瓶颈。对于performance tuning的各种问题我们可以交流下，呵呵</div>

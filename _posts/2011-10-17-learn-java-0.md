--- 
title: 学习Java-上
type: post
layout: post
tags: 
- Java
---

无意中翻出了我大三那年在科协写的《Java学习笔记》，现在看看都忘光了。

贴出来供入门的童鞋拍砖！

####关于对象

*==* 表示引用的变量的值是否相等

*equal()* 表示对象的内容是否相同

		String str1 = new string("abc");
		String str2 = new string("abc");
		Str1==str2 返回的是false


####关于构造方法

*P1 = new person(string name,int age);*

当new一个对象时，第一步是在堆中申请空间，第二步并不是执行构造方法中的赋值，而是先执行显示的变量赋值，将name age 的值置为显示赋值的值，第三步才是执行构造方法中的函数赋值


####关于this

*this*关键字在java程序里的作用和它的词义很接近，它在函数内部就是这个函数所属的对象的引用变量。 

个人理解：

this就是指代调用自己的那个对象，因为在编写方法的时候并不知道将来会是哪个对象调用自己，所以如果在自己这个方法中想调用其他的方法，无法确定“对象.方法”中的对象，设计this指针实现这一点。自己运行的时候一定是有一个对象存在的，调用自己的那个对象就是this


同一个类中，一个成员方法可以直接调用同类的另一个成员方法，省略this，这也是可以的

		{
			…………
			Void fun1(){}
			Void fun2(){
			Fun1();
			}
			…………
		}

有些情况非用this不可，例如：

+ 构造函数 

		public person(string name){
			this.name = name; //防止参数和成员变量重名；
		}

+ 可以在一个构造方法里调用其他重载的构造方法，不是用构造方法名，而是用this(参数列表)的形式，根据其中的参数列表，选择相应的构造方法。 
+ 特殊调用情况


####关于垃圾回收

+ c++中的析构方法 
+ 释放对象在生成中占用的资源
+ java中的finalize()方法 
+ 对象被彻底清除之前被调用，垃圾回收器是不能控制的。
+ Public void finalize() 是被自动调用的，但不一定什么时候调用。
+ System.gc（）的作用 垃圾回收器
+ 指派垃圾回收器收回垃圾

每个类中都有一个equals方法和finalize方法

不管构造方法还是析构方法 在调用这个方法时，对象还是存在的。否则怎么调用对象的方法呢？！


####关于函数参数传递

直接传递成员给change函数，change函数改变成员的值，不会对对象中的成员有任何影响
如果直接传递对象给change，改变对象中的值时有影响，因为传递对象的名字，等于传递了堆中变量的地址，被两个句柄引用。


####关于static 静态方法

编写一个类的本质是什么？是描述这个类的对象一般具有的的属性和方法！

Static方法：无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份，可以使用static方法，这个方法所有的对象共享内存的一份拷贝，在内存中却只有一份。

#####注意：

+ 静态方法只能调用该类中的静态变量（包括成员和方法），不能调用非静态的变量。这是因为静态方法的使用不需要声明一个对象，而非静态的变量在使用之前必须指定一个对象
+ 静态方法中不能使用this和super，道理同上
+ Main方法是静态的，因为JVM在调用main的时候不需要他的所属对象到底是谁，同理，main中调用类中的非静态方法时，必须先有一个对象，使用该对象才可以调用类中的非静态变量。 
+ 一个类中可以使用不包含在任何方法体中的静态代码块(static block )，当类被载入时，静态代码块被执行，且只被执行一次，静态块经常用来进行类属性的初始化。
+ 类中的静态代码块被自动执行，尽管我们产生了类的多个实例对象，但其中的静态代码块只被执行了一次。当一个程序中用到了其他的类，类是在第一次被使用的时候才被装载，而不是在程序启动时就装载程序中所有可能要用到的类。-------》通过这一点可以推测到，在java程序的import语句中导入的任何包和类，只有被使用了才会被编译到代码模块中，而不是import的包和类都被编译！


####关于内部类

内部类可以使用外部类的变量，包括private类型的变量；但是，外部类不能使用内部类的变量

内部类的好处：

1. 代码紧凑，模块化强！
1. 例如 类A调用类B的对象，调用的过程中类B又需要得到类A的成员变量，如果写成两个类，两个类之间的参数传递很麻烦！！用内部类很简单！！


####注意：

1. 如果内部类定义为static类型的，那么它相当于一个外部类，static的内部类中可声明static成员，但是，非static的内部类中的成员是不能声明为static的。
2. 在内部类对象保存了一个对外部类对象的引用，当内部类的成员方法中访问某一变量时，如果在该方法和内部类中都没有定义过这个变量，内部类中对this的引用会被传递给那个外部类对象的引用
3. 如果函数的局部变量（函数的形参也是局部变量），内部类的成员变量，外部类的成员变量重名，我们应该按下面的程序代码所使用的方式来明确指定我们真正要访问的变量。 

		public class Outer
		{
			private int size;
			public class Inner
			{
				private int size;
				public void doStuff( int size)
				{
					size++; // 引用的是doStuff函数的形参
					this.size++; //引用的是Inner类中的成员变量	
					Outer.this.size++; // 引用的Outer类中的成员变量
				}
			}
		}

4.在方法中定义的内部类只能访问方法中的final类型的局部变量，不能访问方法中的普通局部变量，用final定义的局部变量相当于是一个常量，它的生命周期超出方法运行的生命周期。在类中定义的局部变量，编译器可以自动初始化，但在方法中定义的局部变量，编译器是不可以进行初始化的，必须由程序员手工进行初始化。


内部类被外部类引用的例子

		class Outer
		{
			private int size=10;
			public class Inner
			{
				public void doStuff()
				{
					System.out.println(++size);
				}
			}
		}
		public class TestInner
		{
			public static void main( String[] args)
			{
				Outer outer = new Outer();
				Outer.Inner inner = outer.new Inner();
				inner.doStuff();
			}
		}


##### 注意：在一个类中需要实例化另一个类的内部类，先实例化外部类，再实例化内部类！


####关于Java的文档注释

1. 类和方法的说明应该在类和方法的定义之前
2. 批注参数来标记一些特殊的属性及其相应的说明 。

+ @author<作者姓名>
+ @version<版本信息>
+ @param<参数名称><参数说明>
+ @return<返回值说明>

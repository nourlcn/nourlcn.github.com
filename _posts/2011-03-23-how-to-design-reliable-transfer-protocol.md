---
title:  how to design reliable transfer protocol
type: post
layout: post
tags: 
- Notes
- TCP
---
在传输层，最主要的两个协议是TCP和UDP,我们一般说TCP是面向连接+可靠的,说UDP是非连接+不可靠的.<br/><br/>抛开ISO的7层网络模型和TCP-IP模型，单纯从网络结构和原理方面考虑，如何在传输层设计一个可靠的传输协议呢？<br/><br/>想通了这个问题，也就理解了TCP中，为什么会有checksum字段、为什么会有三次握手、为什么会有ACK······<br/><h3>Step1. What ? 什么是可靠传输？</h3><br/>提及可靠传输，我们常以TCP为例子，并且说UDP是不可靠的，TCP是可靠的，为什么呢？<br/><br/>简单来讲，可靠就是在当前的网络状态作为算法输入的情况下，使用这种协议，算法输出的是一个连接的无错的网络状态，用这种状态进行通信。<br/><br/>我们可以把数据传输所经过的 不可靠网络channel，加上reliable data transfer protocol进行封装，使其变成可靠的传输通道<br/><h3>Step2. Why ? 为什么需要可靠传输？</h3><br/>网络状态的不确定性，导致数据的传输可能存在乱序、丢包、错误、阻塞等问题。<br/><br/>设计一个可靠的传输协议就是解决这些问题。<br/><h3>Step3. How ? 如何设计可靠传输协议？</h3><br/>传输中出现的种种问题，既和发送方有关，也和接收方有关系，并且受到网络状态的影响。<br/><br/>我们把所有这些可能影响可靠性的条件作为算法的输入参数，算法的执行结果就是得到数据的可靠的传输，设计可靠传输协议的过程，就是算法的执行过程。<br/><br/>通过将理想的模型（输入参数为0）不断复杂化（增加输入的参数，越来越接近现实情况），逐步接近真实的网络状况<br/><br/>前提：A为发送方，B为接收方，A和B之间使用<a href="http://nourlcn.ownlinux.net/www.hudong.com/wiki/停止等待协议" target="_blank">停等协议</a><br/><h4>a.所有的数据在传输后，都可以正确到达</h4><br/>那么A发送数据Data后，B接受数据，因为网络中没有丢包，没有错误发生，这种网络是可靠的。<br/><br/>那我们可以考虑加入一个参数，使a中的理想网络接近现实网络。<br/><h4>b.数据在传输的过程中，仅可能在data packets中发生error，但不会丢包</h4><br/>在这种情况下，A发送了数据Data，B接收到了数据。因为通过网络传输的数据，是有可能发生error的，比如数据中01位的翻转，B怎么知道自己接受到的数据是正确的，还是在传输的过程中发生了错误呢？<br/><br/>B要想知道数据是否发生了错误，必须对数据进行检查，最简单的方式就是对数据进行校验，因此，协议中增加cheksum，用来校验数据B接收到的数据是否正确。<br/><br/> <br/><br/>问题又来了，如果B校验发现，接收到的数据错误，怎么办？如何recover from error? 这里可能有两种思路：<br/><br/>+ 有些校验方式，可以检测出具体哪些位发生了error（比如海明码可以纠正一位差错），如果使用这种方式，B可以对数据进行恢复。但这种方式可行么？<br/><br/>发生error的数据毕竟是少部分，网络中的数据量很大，这种可以纠错的校验计算起来要比简单的校验复杂的多，对每个收到的数据包都进行这种校验将会得不偿失。<br/><br/>+ 最直接的方式就是，让A重新发送一份Data<br/><br/>那A如何知道数据错误了，需要重新发送呢？<br/><br/>因此，B在收到data之后，需要给A一个反馈，告诉A数据是否正确，正确的数据，B可以发送ACK，错误的数据，B发送NAK。<br/><br/>（暂时假设，ACK和NAK在传输的过程中不会发生error）<br/><br/>A在收到NAK之后，说明刚刚发送的数据出现了错误，对数据进行重传即可。<br/><br/>这里的协议已经可以进行error detection，并且receiver可以对接收到的数据进行feedback<br/><br/> <br/><br/>到这里，我们考虑那个暂时的假设吧！上面设计的协议有个致命的问题，就是我们刚刚忽略的：“如果ACK或者NAK在传输的过程中发生了错误怎么办？”<br/><br/>如果发生了错误，sender A 就不会知道reciever B到底发生了什么事情（因为不管正确接受或者错误，feedback都有可能发生错误，向A反馈了不真实的信息）<br/><br/> <br/><br/>从A sender方面考虑，如果接受到了NAK，那么重传，B收到A发送的数据，1.之前的数据发生了error 2.之前的数据正确，向A发送ACK的时候发生了error<br/><br/>如果是2这种情况，那么A的重传就是duplicate，那B怎么知道这份数据是新数据，还是duplicate呢？<br/><br/>这里必须对先后到达的两个数据（最少两个，并且在我们假设使用send-stop停等协议的情况下，需要区分先后的两个数据包就可以了）进行区分：<br/><br/>最简单的办法就是为每个数据包进行编号，使用sequence number<br/><br/>（这里终于明白为什么协议中要使用sequence number了）<br/><br/>使用sequence number，B在收到数据包的时候，就知道当前接收到的数据，是新的数据还是duplicate<br/><br/> <br/><br/>再提示一下：在此之前考虑的网络，是不存在loss的，只可能发生error，并且AB之间是一个send-stop的过程。<br/><br/> <br/><h4>c.数据在传输的过程中，允许lose packets</h4><br/>现在修改问题（算法）的输入，如果AB之间的网络，允许lose packets，会是什么情况？<br/><br/>在目前设计的协议中，已经引入了checksumseqACK and NAKretransmission，仅使用这些字段，可以解决lose packets的问题么？<br/><br/>很明显是不可以的，如果A发送到B的数据包丢失了，B是不会察觉到的，B会继续等待A发送的数据包，A会一直等待B的ACK或者NAK，这就陷入了僵持阶段。<br/><br/> <br/><br/>合理的做法就是，不能让AB这样一直等下去，在等待一个reasonable amount of time后，就需要做点什么（可以是重传，也可以是询问对方，是否收到等）<br/><br/>这个合理的时间，就是发送之后等待的时间，称作timeout<br/><br/>A在发送数据后，在timeout时间后，如果没有收到B的ACK或者NAK，说明之前发送的数据包发生了问题（问题可以发生在两个地方：A发送的数据有问题，或者Bfeedback的信息有问题），此时，A重传之前发送的数据。<br/><br/>深入的想一下：如果packets没有丢失，但是延迟超过了timeout，会是什么情况呢？<br/><br/>+A会重传之前的packet<br/><br/>+B在收到packets后，可以通过sequence number来辨别是新的packet还是duplicate<br/><br/>+这里需要一个计时器，timer来进行计时<br/><br/>在考虑一个问题，如果packet没有丢失，B在收到packet后发送ACK to A,但是ACK在传输的过程中，由于延迟导致超时发生，会发生什么情况？<br/><br/>+A会重传packet<br/><br/>+B在收到packet后检查sequence number<br/><br/> <br/><br/>这里的算法输入已经接近真实的网络了（可以丢包、乱序到达、允许发生error），A和B之间使用Send-Stop的方式进行通讯太过简单，将协议设计成pipelined protocol,可以提高A和B的效率。<br/><br/>成熟的pipelined protocols有：go-Back-N（回退N帧）和selective repeat（选择重传）<br/><br/>为了支持multiple and acknowledged packets的传输：<br/><br/>+需要增加序列号的范围，仅仅区分连续的两个packets已经不够了<br/><br/>+发送方和接收方需要缓存ack和packets<br/><br/> <br/><br/>......<br/><br/>[最后修改：2011-04-7]<br/><br/> 

